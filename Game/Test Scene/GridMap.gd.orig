extends GridMap
signal finished_moving_shape

onready var input_timer : Timer = $InputTimer
onready var shape_moving = false

func _ready():
	for node in get_spatial_children():
		var t = world_to_map(node.translation)
		print("setting cube " + str(node.translation))
		set_cell_item(t[0], t[1], t[2], node.type)

func get_spatial_children():
	var c = Array()
	for n in get_children():
		if n is Spatial:
			c.append(n)
	return c

func get_cell_pawn(cell : Vector3):
	# By having this function we don't need to keep an array of all of its child objects
	for node in get_spatial_children():
		if world_to_map(node.translation) == cell:
			return node

func get_whole_shape(cell : Vector3, visited : Array = []):
	for c in get_neighbours(cell):
		if not c in visited and c != null:
			visited.append(c)
			get_whole_shape(c.translation, visited)
			
	if not visited:
		visited.append(get_cell_pawn(world_to_map(cell)))
	return visited
	
func get_neighbours(cell_translation : Vector3):
	var adjacent_directions = [Vector3.LEFT, Vector3.RIGHT, Vector3.UP, Vector3.DOWN, Vector3.FORWARD, Vector3.BACK]
	var neighbours = []
	for d in adjacent_directions:
		var n = world_to_map(cell_translation) + d
		var result = get_cell_item(n[0], n[1], n[2])
		if result != -1:
			neighbours.append(get_cell_pawn(n))
	return neighbours

func move_whole_shape(cells : Array, direction : Vector3):
	var pivot_point
	for d in cells:
		if d.translation[1] != 1:
			continue
		if not pivot_point:
			pivot_point = d.translation
		else:
			if d.translation.dot(direction) > pivot_point.dot(direction):
				pivot_point = d.translation
	pivot_point = pivot_point + direction*cell_size/2 + Vector3.DOWN*cell_size/2
	
	for c in cells:
		if not pivot_point:
			continue

		var t = c.translation
		var old_pos = world_to_map(t)
		var new_t = c.move(direction, pivot_point)
		var new_pos = world_to_map(new_t)
		set_cell_item(old_pos[0], old_pos[1], old_pos[2], -1)
		set_cell_item(new_pos[0], new_pos[1], new_pos[2], c.type)
<<<<<<< HEAD
		
		c.move(direction, world_pos)
		if c == cells[-1]:
			yield(c, "finished_moving")
	emit_signal("finished_moving_shape")
		
=======
>>>>>>> shape_improvements
		


func _input(event):
	handle_interact(event)

func handle_interact(event):
	var d = {}

	if Input.is_action_just_pressed("FirstAction"):
		var result_dict = get_object_under_mouse()
		var object = result_dict["collider"] if result_dict.has("collider") else null
		if object == self:
			var pos = world_to_map(result_dict["position"])
			var child = get_cell_pawn(pos)
			if child:
				child.select_or_deselect()
	elif Input.is_action_pressed("Forward") and not shape_moving:
		for child in get_spatial_children():
			if child.is_selected():
				var whole_shape = get_whole_shape(child.translation)
				shape_moving = true
				move_whole_shape(whole_shape, Vector3.FORWARD)
				yield(self, "finished_moving_shape")
				shape_moving = false
	elif Input.is_action_pressed("Down") and not shape_moving:
		for child in get_spatial_children():
			if child.is_selected():
				var whole_shape = get_whole_shape(child.translation)
				shape_moving = true
				move_whole_shape(whole_shape, Vector3.BACK)
				yield(self, "finished_moving_shape")
				shape_moving = false
	elif Input.is_action_pressed("Left") and not shape_moving:
		for child in get_spatial_children():
			if child.is_selected():
				var whole_shape = get_whole_shape(child.translation)
				shape_moving = true
				move_whole_shape(whole_shape, Vector3.LEFT)
				yield(self, "finished_moving_shape")
				shape_moving = false
	elif Input.is_action_pressed("Right") and not shape_moving:
		for child in get_spatial_children():
			if child.is_selected():
				var whole_shape = get_whole_shape(child.translation)
				shape_moving = true
				move_whole_shape(whole_shape, Vector3.RIGHT)
				yield(self, "finished_moving_shape")
				shape_moving = false
			
				
func get_object_under_mouse() -> Dictionary:
	var mouse_pos = get_viewport().get_mouse_position()
	var camera = get_viewport().get_camera()
	var ray_from = camera.project_ray_origin(mouse_pos)
	var ray_to = ray_from + camera.project_ray_normal(mouse_pos) * 1000
	var space_state = get_world().direct_space_state
	var selection = space_state.intersect_ray(ray_from, ray_to)
	if selection:
		selection["position"] = selection["position"] + (ray_to-ray_from)*0.0001
	print(selection)
	return selection